// Package genserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.1 DO NOT EDIT.
package genserver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/pkg/errors"
)

// Defines values for JobState.
const (
	JobStateDone JobState = "done"

	JobStateFailed JobState = "failed"

	JobStateQueued JobState = "queued"

	JobStateQueuedHeld JobState = "queuedHeld"

	JobStateRequeued JobState = "requeued"

	JobStateRequeuedHeld JobState = "requeuedHeld"

	JobStateRunning JobState = "running"

	JobStateSuspended JobState = "suspended"

	JobStateUndetermined JobState = "undetermined"

	JobStateUnset JobState = "unset"
)

// AddArrayJobOutput defines model for AddArrayJobOutput.
type AddArrayJobOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobID)
	JobID `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// AddJobOutput defines model for AddJobOutput.
type AddJobOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobID)
	JobID `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// error string
type Error string

// JobID defines model for JobID.
type JobID string

// JobInfo defines model for JobInfo.
type JobInfo struct {
	AllocatedMachines []string  `json:"allocatedMachines"`
	Annotation        string    `json:"annotation"`
	CpuTime           int64     `json:"cpuTime"`
	DispatchTime      time.Time `json:"dispatchTime"`
	ExitStatus        int       `json:"exitStatus"`
	FinishTime        time.Time `json:"finishTime"`
	Id                string    `json:"id"`
	JobOwner          string    `json:"jobOwner"`
	QueueName         string    `json:"queueName"`
	Slots             int       `json:"slots"`
	State             string    `json:"state"`
	SubState          string    `json:"subState"`
	SubmissionMachine string    `json:"submissionMachine"`
	SubmissionTime    time.Time `json:"submissionTime"`
	TerminatingSignal string    `json:"terminatingSignal"`
	WallclockTime     int64     `json:"wallclockTime"`
}

// JobInfoOutput defines model for JobInfoOutput.
type JobInfoOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobInfo)
	JobInfo `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// JobState defines model for JobState.
type JobState string

// JobStateOutput defines model for JobStateOutput.
type JobStateOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobState)
	JobState `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/JobSubState)
	JobSubState `yaml:",inline"`
}

// JobSubState defines model for JobSubState.
type JobSubState string

// DRMAA2 job template definition
type JobTemplate struct {
	AccountingID      string                     `json:"accountingID"`
	Args              []string                   `json:"args"`
	CandidateMachines []string                   `json:"candidateMachines"`
	DeadlineTime      time.Time                  `json:"deadlineTime"`
	Email             []string                   `json:"email"`
	EmailOnStarted    bool                       `json:"emailOnStarted"`
	EmailOnTerminated bool                       `json:"emailOnTerminated"`
	ErrorPath         string                     `json:"errorPath"`
	InputPath         string                     `json:"inputPath"`
	JobCategory       string                     `json:"jobCategory"`
	JobEnvironment    JobTemplate_JobEnvironment `json:"jobEnvironment"`
	JobName           string                     `json:"jobName"`
	JoinFiles         bool                       `json:"joinFiles"`
	MachineArch       string                     `json:"machineArch"`
	MachineOs         string                     `json:"machineOs"`
	MaxSlots          int64                      `json:"maxSlots"`
	MinPhysMemory     int64                      `json:"minPhysMemory"`
	MinSlots          int64                      `json:"minSlots"`
	OutputPath        string                     `json:"outputPath"`
	Priority          int64                      `json:"priority"`
	QueueName         string                     `json:"queueName"`
	ReRunnable        bool                       `json:"reRunnable"`
	RemoteCommand     string                     `json:"remoteCommand"`
	ReservationID     string                     `json:"reservationID"`
	ResourceLimits    JobTemplate_ResourceLimits `json:"resourceLimits"`
	StageInFiles      JobTemplate_StageInFiles   `json:"stageInFiles"`
	StageOutFiles     JobTemplate_StageOutFiles  `json:"stageOutFiles"`
	StartTime         time.Time                  `json:"startTime"`
	SubmitAsHold      bool                       `json:"submitAsHold"`
	WorkingDirectory  string                     `json:"workingDirectory"`
}

// JobTemplate_JobEnvironment defines model for JobTemplate.JobEnvironment.
type JobTemplate_JobEnvironment struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_ResourceLimits defines model for JobTemplate.ResourceLimits.
type JobTemplate_ResourceLimits struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_StageInFiles defines model for JobTemplate.StageInFiles.
type JobTemplate_StageInFiles struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_StageOutFiles defines model for JobTemplate.StageOutFiles.
type JobTemplate_StageOutFiles struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AddArrayJobJSONBody defines parameters for AddArrayJob.
type AddArrayJobJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/JobTemplate)
	JobTemplate `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Begin       int64  `json:"begin"`
	End         int64  `json:"end"`
	MaxParallel *int64 `json:"maxParallel,omitempty"`
	Step        *int64 `json:"step,omitempty"`
}

// AddJobJSONBody defines parameters for AddJob.
type AddJobJSONBody JobTemplate

// DeleteJobParams defines parameters for DeleteJob.
type DeleteJobParams struct {

	// ID of the job to manipulate
	JobID string `json:"jobID"`
}

// JobControlParams defines parameters for JobControl.
type JobControlParams struct {

	// ID of the job to manipulate
	JobID string `json:"jobID"`

	// action to perform (suspend, resume, hold, release, terminate)
	Action JobControlParamsAction `json:"action"`
}

// JobControlParamsAction defines parameters for JobControl.
type JobControlParamsAction string

// JobInfoParams defines parameters for JobInfo.
type JobInfoParams struct {

	// ID if the job for which the JobInfo should be returned
	JobID string `json:"jobID"`
}

// JobStateParams defines parameters for JobState.
type JobStateParams struct {

	// job ID the current job state should be queried for
	JobID string `json:"jobID"`
}

// ListArrayJobsParams defines parameters for ListArrayJobs.
type ListArrayJobsParams struct {

	// array job ID
	ArrayJobID string `json:"arrayJobID"`

	// number of records to skip for pagination
	Skip *int32 `json:"skip,omitempty"`

	// Maximum number of records to return. If not given the number of records are not limited.
	Limit *int32 `json:"limit,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {

	// number of records to skip for pagination
	Skip *int32 `json:"skip,omitempty"`

	// maximum number of records to return
	Limit *int32 `json:"limit,omitempty"`
}

// AddArrayJobJSONRequestBody defines body for AddArrayJob for application/json ContentType.
type AddArrayJobJSONRequestBody AddArrayJobJSONBody

// AddJobJSONRequestBody defines body for AddJob for application/json ContentType.
type AddJobJSONRequestBody AddJobJSONBody

// Getter for additional properties for JobTemplate_JobEnvironment. Returns the specified
// element and whether it was found
func (a JobTemplate_JobEnvironment) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_JobEnvironment
func (a *JobTemplate_JobEnvironment) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_JobEnvironment to handle AdditionalProperties
func (a *JobTemplate_JobEnvironment) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_JobEnvironment to handle AdditionalProperties
func (a JobTemplate_JobEnvironment) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_ResourceLimits. Returns the specified
// element and whether it was found
func (a JobTemplate_ResourceLimits) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_ResourceLimits
func (a *JobTemplate_ResourceLimits) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_ResourceLimits to handle AdditionalProperties
func (a *JobTemplate_ResourceLimits) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_ResourceLimits to handle AdditionalProperties
func (a JobTemplate_ResourceLimits) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_StageInFiles. Returns the specified
// element and whether it was found
func (a JobTemplate_StageInFiles) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_StageInFiles
func (a *JobTemplate_StageInFiles) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_StageInFiles to handle AdditionalProperties
func (a *JobTemplate_StageInFiles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_StageInFiles to handle AdditionalProperties
func (a JobTemplate_StageInFiles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_StageOutFiles. Returns the specified
// element and whether it was found
func (a JobTemplate_StageOutFiles) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_StageOutFiles
func (a *JobTemplate_StageOutFiles) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_StageOutFiles to handle AdditionalProperties
func (a *JobTemplate_StageOutFiles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_StageOutFiles to handle AdditionalProperties
func (a JobTemplate_StageOutFiles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// submits a set of jobs sharing the same job template
	// (POST /addarrayjob)
	AddArrayJob(w http.ResponseWriter, r *http.Request)
	// submits a job based on a job template
	// (POST /addjob)
	AddJob(w http.ResponseWriter, r *http.Request)
	// removes a finished job from interal DB
	// (GET /deletejob)
	DeleteJob(w http.ResponseWriter, r *http.Request, params DeleteJobParams)
	// changes the state of a job
	// (GET /jobcontrol)
	JobControl(w http.ResponseWriter, r *http.Request, params JobControlParams)
	// retuns detailed information about a job
	// (GET /jobinfo)
	JobInfo(w http.ResponseWriter, r *http.Request, params JobInfoParams)
	// returns the state of a job
	// (GET /jobstate)
	JobState(w http.ResponseWriter, r *http.Request, params JobStateParams)
	// lists job IDs for a given array job ID
	// (GET /listarrayjobs)
	ListArrayJobs(w http.ResponseWriter, r *http.Request, params ListArrayJobsParams)
	// returns available job categories
	// (GET /listjobcategories)
	ListJobCategories(w http.ResponseWriter, r *http.Request)
	// lists jobs managed by jobtracker
	// (GET /listjobs)
	ListJobs(w http.ResponseWriter, r *http.Request, params ListJobsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// AddArrayJob operation middleware
func (siw *ServerInterfaceWrapper) AddArrayJob(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddArrayJob(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddJob operation middleware
func (siw *ServerInterfaceWrapper) AddJob(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddJob(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteJob operation middleware
func (siw *ServerInterfaceWrapper) DeleteJob(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteJobParams

	// ------------- Required query parameter "jobID" -------------
	if paramValue := r.URL.Query().Get("jobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument jobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "jobID", r.URL.Query(), &params.JobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter jobID: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteJob(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// JobControl operation middleware
func (siw *ServerInterfaceWrapper) JobControl(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params JobControlParams

	// ------------- Required query parameter "jobID" -------------
	if paramValue := r.URL.Query().Get("jobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument jobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "jobID", r.URL.Query(), &params.JobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter jobID: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "action" -------------
	if paramValue := r.URL.Query().Get("action"); paramValue != "" {

	} else {
		http.Error(w, "Query argument action is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter action: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JobControl(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// JobInfo operation middleware
func (siw *ServerInterfaceWrapper) JobInfo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params JobInfoParams

	// ------------- Required query parameter "jobID" -------------
	if paramValue := r.URL.Query().Get("jobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument jobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "jobID", r.URL.Query(), &params.JobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter jobID: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JobInfo(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// JobState operation middleware
func (siw *ServerInterfaceWrapper) JobState(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params JobStateParams

	// ------------- Required query parameter "jobID" -------------
	if paramValue := r.URL.Query().Get("jobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument jobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "jobID", r.URL.Query(), &params.JobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter jobID: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JobState(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListArrayJobs operation middleware
func (siw *ServerInterfaceWrapper) ListArrayJobs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListArrayJobsParams

	// ------------- Required query parameter "arrayJobID" -------------
	if paramValue := r.URL.Query().Get("arrayJobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument arrayJobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "arrayJobID", r.URL.Query(), &params.ArrayJobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter arrayJobID: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "skip" -------------
	if paramValue := r.URL.Query().Get("skip"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "skip", r.URL.Query(), &params.Skip)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter skip: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListArrayJobs(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListJobCategories operation middleware
func (siw *ServerInterfaceWrapper) ListJobCategories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobCategories(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListJobs operation middleware
func (siw *ServerInterfaceWrapper) ListJobs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams

	// ------------- Optional query parameter "skip" -------------
	if paramValue := r.URL.Query().Get("skip"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "skip", r.URL.Query(), &params.Skip)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter skip: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobs(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/addarrayjob", wrapper.AddArrayJob)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/addjob", wrapper.AddJob)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/deletejob", wrapper.DeleteJob)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/jobcontrol", wrapper.JobControl)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/jobinfo", wrapper.JobInfo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/jobstate", wrapper.JobState)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/listarrayjobs", wrapper.ListArrayJobs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/listjobcategories", wrapper.ListJobCategories)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/listjobs", wrapper.ListJobs)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

