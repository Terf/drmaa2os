// Package genserver provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.1 DO NOT EDIT.
package genserver

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/pkg/errors"
)

// Defines values for JobState.
const (
	JobStateDone JobState = "done"

	JobStateFailed JobState = "failed"

	JobStateQueued JobState = "queued"

	JobStateQueuedHeld JobState = "queuedHeld"

	JobStateRequeued JobState = "requeued"

	JobStateRequeuedHeld JobState = "requeuedHeld"

	JobStateRunning JobState = "running"

	JobStateSuspended JobState = "suspended"

	JobStateUndetermined JobState = "undetermined"

	JobStateUnset JobState = "unset"
)

// AddArrayJobOutput defines model for AddArrayJobOutput.
type AddArrayJobOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobID)
	JobID `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// AddJobOutput defines model for AddJobOutput.
type AddJobOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobID)
	JobID `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// error string
type Error string

// JobID defines model for JobID.
type JobID string

// JobInfo defines model for JobInfo.
type JobInfo struct {
	AllocatedMachines []string           `json:"allocatedMachines"`
	Annotation        string             `json:"annotation"`
	CpuTime           int64              `json:"cpuTime"`
	DispatchTime      time.Time          `json:"dispatchTime"`
	ExitStatus        int                `json:"exitStatus"`
	Extension         *JobInfo_Extension `json:"extension,omitempty"`
	FinishTime        time.Time          `json:"finishTime"`
	Id                string             `json:"id"`
	JobOwner          string             `json:"jobOwner"`
	QueueName         string             `json:"queueName"`
	Slots             int                `json:"slots"`
	State             string             `json:"state"`
	SubState          string             `json:"subState"`
	SubmissionMachine string             `json:"submissionMachine"`
	SubmissionTime    time.Time          `json:"submissionTime"`
	TerminatingSignal string             `json:"terminatingSignal"`
	WallclockTime     int64              `json:"wallclockTime"`
}

// JobInfo_Extension defines model for JobInfo.Extension.
type JobInfo_Extension struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobInfoOutput defines model for JobInfoOutput.
type JobInfoOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobInfo)
	JobInfo `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// JobState defines model for JobState.
type JobState string

// JobStateOutput defines model for JobStateOutput.
type JobStateOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobState)
	JobState `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/JobSubState)
	JobSubState `yaml:",inline"`
}

// JobSubState defines model for JobSubState.
type JobSubState string

// DRMAA2 job template definition
type JobTemplate struct {
	AccountingID      string                     `json:"accountingID"`
	Args              []string                   `json:"args"`
	CandidateMachines []string                   `json:"candidateMachines"`
	DeadlineTime      time.Time                  `json:"deadlineTime"`
	Email             []string                   `json:"email"`
	EmailOnStarted    bool                       `json:"emailOnStarted"`
	EmailOnTerminated bool                       `json:"emailOnTerminated"`
	ErrorPath         string                     `json:"errorPath"`
	Extension         *JobTemplate_Extension     `json:"extension,omitempty"`
	InputPath         string                     `json:"inputPath"`
	JobCategory       string                     `json:"jobCategory"`
	JobEnvironment    JobTemplate_JobEnvironment `json:"jobEnvironment"`
	JobName           string                     `json:"jobName"`
	JoinFiles         bool                       `json:"joinFiles"`
	MachineArch       string                     `json:"machineArch"`
	MachineOs         string                     `json:"machineOs"`
	MaxSlots          int64                      `json:"maxSlots"`
	MinPhysMemory     int64                      `json:"minPhysMemory"`
	MinSlots          int64                      `json:"minSlots"`
	OutputPath        string                     `json:"outputPath"`
	Priority          int64                      `json:"priority"`
	QueueName         string                     `json:"queueName"`
	ReRunnable        bool                       `json:"reRunnable"`
	RemoteCommand     string                     `json:"remoteCommand"`
	ReservationID     string                     `json:"reservationID"`
	ResourceLimits    JobTemplate_ResourceLimits `json:"resourceLimits"`
	StageInFiles      JobTemplate_StageInFiles   `json:"stageInFiles"`
	StageOutFiles     JobTemplate_StageOutFiles  `json:"stageOutFiles"`
	StartTime         time.Time                  `json:"startTime"`
	SubmitAsHold      bool                       `json:"submitAsHold"`
	WorkingDirectory  string                     `json:"workingDirectory"`
}

// JobTemplate_Extension defines model for JobTemplate.Extension.
type JobTemplate_Extension struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_JobEnvironment defines model for JobTemplate.JobEnvironment.
type JobTemplate_JobEnvironment struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_ResourceLimits defines model for JobTemplate.ResourceLimits.
type JobTemplate_ResourceLimits struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_StageInFiles defines model for JobTemplate.StageInFiles.
type JobTemplate_StageInFiles struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_StageOutFiles defines model for JobTemplate.StageOutFiles.
type JobTemplate_StageOutFiles struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AddArrayJobJSONBody defines parameters for AddArrayJob.
type AddArrayJobJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/JobTemplate)
	JobTemplate `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Begin       int64  `json:"begin"`
	End         int64  `json:"end"`
	MaxParallel *int64 `json:"maxParallel,omitempty"`
	Step        *int64 `json:"step,omitempty"`
}

// AddJobJSONBody defines parameters for AddJob.
type AddJobJSONBody JobTemplate

// DeleteJobParams defines parameters for DeleteJob.
type DeleteJobParams struct {

	// ID of the job to manipulate
	JobID string `json:"jobID"`
}

// JobControlParams defines parameters for JobControl.
type JobControlParams struct {

	// ID of the job to manipulate
	JobID string `json:"jobID"`

	// action to perform (suspend, resume, hold, release, terminate)
	Action JobControlParamsAction `json:"action"`
}

// JobControlParamsAction defines parameters for JobControl.
type JobControlParamsAction string

// JobInfoParams defines parameters for JobInfo.
type JobInfoParams struct {

	// ID if the job for which the JobInfo should be returned
	JobID string `json:"jobID"`
}

// JobStateParams defines parameters for JobState.
type JobStateParams struct {

	// job ID the current job state should be queried for
	JobID string `json:"jobID"`
}

// ListArrayJobsParams defines parameters for ListArrayJobs.
type ListArrayJobsParams struct {

	// array job ID
	ArrayJobID string `json:"arrayJobID"`

	// number of records to skip for pagination
	Skip *int32 `json:"skip,omitempty"`

	// Maximum number of records to return. If not given the number of records are not limited.
	Limit *int32 `json:"limit,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {

	// number of records to skip for pagination
	Skip *int32 `json:"skip,omitempty"`

	// maximum number of records to return
	Limit *int32 `json:"limit,omitempty"`
}

// AddArrayJobJSONRequestBody defines body for AddArrayJob for application/json ContentType.
type AddArrayJobJSONRequestBody AddArrayJobJSONBody

// AddJobJSONRequestBody defines body for AddJob for application/json ContentType.
type AddJobJSONRequestBody AddJobJSONBody

// Getter for additional properties for JobInfo_Extension. Returns the specified
// element and whether it was found
func (a JobInfo_Extension) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobInfo_Extension
func (a *JobInfo_Extension) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobInfo_Extension to handle AdditionalProperties
func (a *JobInfo_Extension) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobInfo_Extension to handle AdditionalProperties
func (a JobInfo_Extension) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_Extension. Returns the specified
// element and whether it was found
func (a JobTemplate_Extension) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_Extension
func (a *JobTemplate_Extension) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_Extension to handle AdditionalProperties
func (a *JobTemplate_Extension) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_Extension to handle AdditionalProperties
func (a JobTemplate_Extension) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_JobEnvironment. Returns the specified
// element and whether it was found
func (a JobTemplate_JobEnvironment) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_JobEnvironment
func (a *JobTemplate_JobEnvironment) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_JobEnvironment to handle AdditionalProperties
func (a *JobTemplate_JobEnvironment) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_JobEnvironment to handle AdditionalProperties
func (a JobTemplate_JobEnvironment) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_ResourceLimits. Returns the specified
// element and whether it was found
func (a JobTemplate_ResourceLimits) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_ResourceLimits
func (a *JobTemplate_ResourceLimits) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_ResourceLimits to handle AdditionalProperties
func (a *JobTemplate_ResourceLimits) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_ResourceLimits to handle AdditionalProperties
func (a JobTemplate_ResourceLimits) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_StageInFiles. Returns the specified
// element and whether it was found
func (a JobTemplate_StageInFiles) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_StageInFiles
func (a *JobTemplate_StageInFiles) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_StageInFiles to handle AdditionalProperties
func (a *JobTemplate_StageInFiles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_StageInFiles to handle AdditionalProperties
func (a JobTemplate_StageInFiles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_StageOutFiles. Returns the specified
// element and whether it was found
func (a JobTemplate_StageOutFiles) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_StageOutFiles
func (a *JobTemplate_StageOutFiles) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_StageOutFiles to handle AdditionalProperties
func (a *JobTemplate_StageOutFiles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_StageOutFiles to handle AdditionalProperties
func (a JobTemplate_StageOutFiles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// submits a set of jobs sharing the same job template
	// (POST /addarrayjob)
	AddArrayJob(w http.ResponseWriter, r *http.Request)
	// submits a job based on a job template
	// (POST /addjob)
	AddJob(w http.ResponseWriter, r *http.Request)
	// removes a finished job from interal DB
	// (GET /deletejob)
	DeleteJob(w http.ResponseWriter, r *http.Request, params DeleteJobParams)
	// changes the state of a job
	// (GET /jobcontrol)
	JobControl(w http.ResponseWriter, r *http.Request, params JobControlParams)
	// retuns detailed information about a job
	// (GET /jobinfo)
	JobInfo(w http.ResponseWriter, r *http.Request, params JobInfoParams)
	// returns the state of a job
	// (GET /jobstate)
	JobState(w http.ResponseWriter, r *http.Request, params JobStateParams)
	// lists job IDs for a given array job ID
	// (GET /listarrayjobs)
	ListArrayJobs(w http.ResponseWriter, r *http.Request, params ListArrayJobsParams)
	// returns available job categories
	// (GET /listjobcategories)
	ListJobCategories(w http.ResponseWriter, r *http.Request)
	// lists jobs managed by jobtracker
	// (GET /listjobs)
	ListJobs(w http.ResponseWriter, r *http.Request, params ListJobsParams)
}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler            ServerInterface
	HandlerMiddlewares []MiddlewareFunc
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc

// AddArrayJob operation middleware
func (siw *ServerInterfaceWrapper) AddArrayJob(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddArrayJob(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// AddJob operation middleware
func (siw *ServerInterfaceWrapper) AddJob(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.AddJob(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// DeleteJob operation middleware
func (siw *ServerInterfaceWrapper) DeleteJob(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params DeleteJobParams

	// ------------- Required query parameter "jobID" -------------
	if paramValue := r.URL.Query().Get("jobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument jobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "jobID", r.URL.Query(), &params.JobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter jobID: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.DeleteJob(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// JobControl operation middleware
func (siw *ServerInterfaceWrapper) JobControl(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params JobControlParams

	// ------------- Required query parameter "jobID" -------------
	if paramValue := r.URL.Query().Get("jobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument jobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "jobID", r.URL.Query(), &params.JobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter jobID: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Required query parameter "action" -------------
	if paramValue := r.URL.Query().Get("action"); paramValue != "" {

	} else {
		http.Error(w, "Query argument action is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter action: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JobControl(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// JobInfo operation middleware
func (siw *ServerInterfaceWrapper) JobInfo(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params JobInfoParams

	// ------------- Required query parameter "jobID" -------------
	if paramValue := r.URL.Query().Get("jobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument jobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "jobID", r.URL.Query(), &params.JobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter jobID: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JobInfo(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// JobState operation middleware
func (siw *ServerInterfaceWrapper) JobState(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params JobStateParams

	// ------------- Required query parameter "jobID" -------------
	if paramValue := r.URL.Query().Get("jobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument jobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "jobID", r.URL.Query(), &params.JobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter jobID: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.JobState(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListArrayJobs operation middleware
func (siw *ServerInterfaceWrapper) ListArrayJobs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListArrayJobsParams

	// ------------- Required query parameter "arrayJobID" -------------
	if paramValue := r.URL.Query().Get("arrayJobID"); paramValue != "" {

	} else {
		http.Error(w, "Query argument arrayJobID is required, but not found", http.StatusBadRequest)
		return
	}

	err = runtime.BindQueryParameter("form", true, true, "arrayJobID", r.URL.Query(), &params.ArrayJobID)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter arrayJobID: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "skip" -------------
	if paramValue := r.URL.Query().Get("skip"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "skip", r.URL.Query(), &params.Skip)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter skip: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListArrayJobs(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListJobCategories operation middleware
func (siw *ServerInterfaceWrapper) ListJobCategories(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobCategories(w, r)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// ListJobs operation middleware
func (siw *ServerInterfaceWrapper) ListJobs(w http.ResponseWriter, r *http.Request) {
	ctx := r.Context()

	var err error

	// Parameter object where we will unmarshal all parameters from the context
	var params ListJobsParams

	// ------------- Optional query parameter "skip" -------------
	if paramValue := r.URL.Query().Get("skip"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "skip", r.URL.Query(), &params.Skip)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter skip: %s", err), http.StatusBadRequest)
		return
	}

	// ------------- Optional query parameter "limit" -------------
	if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

	}

	err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
	if err != nil {
		http.Error(w, fmt.Sprintf("Invalid format for parameter limit: %s", err), http.StatusBadRequest)
		return
	}

	var handler = func(w http.ResponseWriter, r *http.Request) {
		siw.Handler.ListJobs(w, r, params)
	}

	for _, middleware := range siw.HandlerMiddlewares {
		handler = middleware(handler)
	}

	handler(w, r.WithContext(ctx))
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
	BaseURL     string
	BaseRouter  chi.Router
	Middlewares []MiddlewareFunc
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseRouter: r,
	})
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
	return HandlerWithOptions(si, ChiServerOptions{
		BaseURL:    baseURL,
		BaseRouter: r,
	})
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
	r := options.BaseRouter

	if r == nil {
		r = chi.NewRouter()
	}
	wrapper := ServerInterfaceWrapper{
		Handler:            si,
		HandlerMiddlewares: options.Middlewares,
	}

	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/addarrayjob", wrapper.AddArrayJob)
	})
	r.Group(func(r chi.Router) {
		r.Post(options.BaseURL+"/addjob", wrapper.AddJob)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/deletejob", wrapper.DeleteJob)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/jobcontrol", wrapper.JobControl)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/jobinfo", wrapper.JobInfo)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/jobstate", wrapper.JobState)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/listarrayjobs", wrapper.ListArrayJobs)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/listjobcategories", wrapper.ListJobCategories)
	})
	r.Group(func(r chi.Router) {
		r.Get(options.BaseURL+"/listjobs", wrapper.ListJobs)
	})

	return r
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"pS4AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

