// Package genclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.1 DO NOT EDIT.
package genclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/pkg/errors"
)

// Defines values for JobState.
const (
	JobStateDone JobState = "done"

	JobStateFailed JobState = "failed"

	JobStateQueued JobState = "queued"

	JobStateQueuedHeld JobState = "queuedHeld"

	JobStateRequeued JobState = "requeued"

	JobStateRequeuedHeld JobState = "requeuedHeld"

	JobStateRunning JobState = "running"

	JobStateSuspended JobState = "suspended"

	JobStateUndetermined JobState = "undetermined"

	JobStateUnset JobState = "unset"
)

// AddArrayJobOutput defines model for AddArrayJobOutput.
type AddArrayJobOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobID)
	JobID `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// AddJobOutput defines model for AddJobOutput.
type AddJobOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobID)
	JobID `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// error string
type Error string

// JobID defines model for JobID.
type JobID string

// JobInfo defines model for JobInfo.
type JobInfo struct {
	AllocatedMachines []string           `json:"allocatedMachines"`
	Annotation        string             `json:"annotation"`
	CpuTime           int64              `json:"cpuTime"`
	DispatchTime      time.Time          `json:"dispatchTime"`
	ExitStatus        int                `json:"exitStatus"`
	Extension         *JobInfo_Extension `json:"extension,omitempty"`
	FinishTime        time.Time          `json:"finishTime"`
	Id                string             `json:"id"`
	JobOwner          string             `json:"jobOwner"`
	QueueName         string             `json:"queueName"`
	Slots             int                `json:"slots"`
	State             string             `json:"state"`
	SubState          string             `json:"subState"`
	SubmissionMachine string             `json:"submissionMachine"`
	SubmissionTime    time.Time          `json:"submissionTime"`
	TerminatingSignal string             `json:"terminatingSignal"`
	WallclockTime     int64              `json:"wallclockTime"`
}

// JobInfo_Extension defines model for JobInfo.Extension.
type JobInfo_Extension struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobInfoOutput defines model for JobInfoOutput.
type JobInfoOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobInfo)
	JobInfo `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// JobState defines model for JobState.
type JobState string

// JobStateOutput defines model for JobStateOutput.
type JobStateOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobState)
	JobState `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/JobSubState)
	JobSubState `yaml:",inline"`
}

// JobSubState defines model for JobSubState.
type JobSubState string

// DRMAA2 job template definition
type JobTemplate struct {
	AccountingID      string                     `json:"accountingID"`
	Args              []string                   `json:"args"`
	CandidateMachines []string                   `json:"candidateMachines"`
	DeadlineTime      time.Time                  `json:"deadlineTime"`
	Email             []string                   `json:"email"`
	EmailOnStarted    bool                       `json:"emailOnStarted"`
	EmailOnTerminated bool                       `json:"emailOnTerminated"`
	ErrorPath         string                     `json:"errorPath"`
	Extension         *JobTemplate_Extension     `json:"extension,omitempty"`
	InputPath         string                     `json:"inputPath"`
	JobCategory       string                     `json:"jobCategory"`
	JobEnvironment    JobTemplate_JobEnvironment `json:"jobEnvironment"`
	JobName           string                     `json:"jobName"`
	JoinFiles         bool                       `json:"joinFiles"`
	MachineArch       string                     `json:"machineArch"`
	MachineOs         string                     `json:"machineOs"`
	MaxSlots          int64                      `json:"maxSlots"`
	MinPhysMemory     int64                      `json:"minPhysMemory"`
	MinSlots          int64                      `json:"minSlots"`
	OutputPath        string                     `json:"outputPath"`
	Priority          int64                      `json:"priority"`
	QueueName         string                     `json:"queueName"`
	ReRunnable        bool                       `json:"reRunnable"`
	RemoteCommand     string                     `json:"remoteCommand"`
	ReservationID     string                     `json:"reservationID"`
	ResourceLimits    JobTemplate_ResourceLimits `json:"resourceLimits"`
	StageInFiles      JobTemplate_StageInFiles   `json:"stageInFiles"`
	StageOutFiles     JobTemplate_StageOutFiles  `json:"stageOutFiles"`
	StartTime         time.Time                  `json:"startTime"`
	SubmitAsHold      bool                       `json:"submitAsHold"`
	WorkingDirectory  string                     `json:"workingDirectory"`
}

// JobTemplate_Extension defines model for JobTemplate.Extension.
type JobTemplate_Extension struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_JobEnvironment defines model for JobTemplate.JobEnvironment.
type JobTemplate_JobEnvironment struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_ResourceLimits defines model for JobTemplate.ResourceLimits.
type JobTemplate_ResourceLimits struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_StageInFiles defines model for JobTemplate.StageInFiles.
type JobTemplate_StageInFiles struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_StageOutFiles defines model for JobTemplate.StageOutFiles.
type JobTemplate_StageOutFiles struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AddArrayJobJSONBody defines parameters for AddArrayJob.
type AddArrayJobJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/JobTemplate)
	JobTemplate `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Begin       int64  `json:"begin"`
	End         int64  `json:"end"`
	MaxParallel *int64 `json:"maxParallel,omitempty"`
	Step        *int64 `json:"step,omitempty"`
}

// AddJobJSONBody defines parameters for AddJob.
type AddJobJSONBody JobTemplate

// DeleteJobParams defines parameters for DeleteJob.
type DeleteJobParams struct {

	// ID of the job to manipulate
	JobID string `json:"jobID"`
}

// JobControlParams defines parameters for JobControl.
type JobControlParams struct {

	// ID of the job to manipulate
	JobID string `json:"jobID"`

	// action to perform (suspend, resume, hold, release, terminate)
	Action JobControlParamsAction `json:"action"`
}

// JobControlParamsAction defines parameters for JobControl.
type JobControlParamsAction string

// JobInfoParams defines parameters for JobInfo.
type JobInfoParams struct {

	// ID if the job for which the JobInfo should be returned
	JobID string `json:"jobID"`
}

// JobStateParams defines parameters for JobState.
type JobStateParams struct {

	// job ID the current job state should be queried for
	JobID string `json:"jobID"`
}

// ListArrayJobsParams defines parameters for ListArrayJobs.
type ListArrayJobsParams struct {

	// array job ID
	ArrayJobID string `json:"arrayJobID"`

	// number of records to skip for pagination
	Skip *int32 `json:"skip,omitempty"`

	// Maximum number of records to return. If not given the number of records are not limited.
	Limit *int32 `json:"limit,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {

	// number of records to skip for pagination
	Skip *int32 `json:"skip,omitempty"`

	// maximum number of records to return
	Limit *int32 `json:"limit,omitempty"`
}

// AddArrayJobJSONRequestBody defines body for AddArrayJob for application/json ContentType.
type AddArrayJobJSONRequestBody AddArrayJobJSONBody

// AddJobJSONRequestBody defines body for AddJob for application/json ContentType.
type AddJobJSONRequestBody AddJobJSONBody

// Getter for additional properties for JobInfo_Extension. Returns the specified
// element and whether it was found
func (a JobInfo_Extension) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobInfo_Extension
func (a *JobInfo_Extension) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobInfo_Extension to handle AdditionalProperties
func (a *JobInfo_Extension) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobInfo_Extension to handle AdditionalProperties
func (a JobInfo_Extension) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_Extension. Returns the specified
// element and whether it was found
func (a JobTemplate_Extension) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_Extension
func (a *JobTemplate_Extension) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_Extension to handle AdditionalProperties
func (a *JobTemplate_Extension) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_Extension to handle AdditionalProperties
func (a JobTemplate_Extension) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_JobEnvironment. Returns the specified
// element and whether it was found
func (a JobTemplate_JobEnvironment) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_JobEnvironment
func (a *JobTemplate_JobEnvironment) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_JobEnvironment to handle AdditionalProperties
func (a *JobTemplate_JobEnvironment) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_JobEnvironment to handle AdditionalProperties
func (a JobTemplate_JobEnvironment) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_ResourceLimits. Returns the specified
// element and whether it was found
func (a JobTemplate_ResourceLimits) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_ResourceLimits
func (a *JobTemplate_ResourceLimits) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_ResourceLimits to handle AdditionalProperties
func (a *JobTemplate_ResourceLimits) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_ResourceLimits to handle AdditionalProperties
func (a JobTemplate_ResourceLimits) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_StageInFiles. Returns the specified
// element and whether it was found
func (a JobTemplate_StageInFiles) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_StageInFiles
func (a *JobTemplate_StageInFiles) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_StageInFiles to handle AdditionalProperties
func (a *JobTemplate_StageInFiles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_StageInFiles to handle AdditionalProperties
func (a JobTemplate_StageInFiles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_StageOutFiles. Returns the specified
// element and whether it was found
func (a JobTemplate_StageOutFiles) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_StageOutFiles
func (a *JobTemplate_StageOutFiles) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_StageOutFiles to handle AdditionalProperties
func (a *JobTemplate_StageOutFiles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_StageOutFiles to handle AdditionalProperties
func (a JobTemplate_StageOutFiles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AddArrayJob request  with any body
	AddArrayJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddArrayJob(ctx context.Context, body AddArrayJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddJob request  with any body
	AddJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddJob(ctx context.Context, body AddJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJob request
	DeleteJob(ctx context.Context, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JobControl request
	JobControl(ctx context.Context, params *JobControlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JobInfo request
	JobInfo(ctx context.Context, params *JobInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JobState request
	JobState(ctx context.Context, params *JobStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListArrayJobs request
	ListArrayJobs(ctx context.Context, params *ListArrayJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobCategories request
	ListJobCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AddArrayJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddArrayJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddArrayJob(ctx context.Context, body AddArrayJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddArrayJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddJob(ctx context.Context, body AddJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJob(ctx context.Context, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JobControl(ctx context.Context, params *JobControlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJobControlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JobInfo(ctx context.Context, params *JobInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJobInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JobState(ctx context.Context, params *JobStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJobStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArrayJobs(ctx context.Context, params *ListArrayJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArrayJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAddArrayJobRequest calls the generic AddArrayJob builder with application/json body
func NewAddArrayJobRequest(server string, body AddArrayJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddArrayJobRequestWithBody(server, "application/json", bodyReader)
}

// NewAddArrayJobRequestWithBody generates requests for AddArrayJob with any type of body
func NewAddArrayJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addarrayjob")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddJobRequest calls the generic AddJob builder with application/json body
func NewAddJobRequest(server string, body AddJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddJobRequestWithBody(server, "application/json", bodyReader)
}

// NewAddJobRequestWithBody generates requests for AddJob with any type of body
func NewAddJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addjob")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobRequest generates requests for DeleteJob
func NewDeleteJobRequest(server string, params *DeleteJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deletejob")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobID", runtime.ParamLocationQuery, params.JobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJobControlRequest generates requests for JobControl
func NewJobControlRequest(server string, params *JobControlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobcontrol")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobID", runtime.ParamLocationQuery, params.JobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJobInfoRequest generates requests for JobInfo
func NewJobInfoRequest(server string, params *JobInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobinfo")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobID", runtime.ParamLocationQuery, params.JobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJobStateRequest generates requests for JobState
func NewJobStateRequest(server string, params *JobStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobstate")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobID", runtime.ParamLocationQuery, params.JobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListArrayJobsRequest generates requests for ListArrayJobs
func NewListArrayJobsRequest(server string, params *ListArrayJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listarrayjobs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrayJobID", runtime.ParamLocationQuery, params.ArrayJobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Skip != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobCategoriesRequest generates requests for ListJobCategories
func NewListJobCategoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listjobcategories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, params *ListJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listjobs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Skip != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AddArrayJob request  with any body
	AddArrayJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddArrayJobResponse, error)

	AddArrayJobWithResponse(ctx context.Context, body AddArrayJobJSONRequestBody, reqEditors ...RequestEditorFn) (*AddArrayJobResponse, error)

	// AddJob request  with any body
	AddJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddJobResponse, error)

	AddJobWithResponse(ctx context.Context, body AddJobJSONRequestBody, reqEditors ...RequestEditorFn) (*AddJobResponse, error)

	// DeleteJob request
	DeleteJobWithResponse(ctx context.Context, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error)

	// JobControl request
	JobControlWithResponse(ctx context.Context, params *JobControlParams, reqEditors ...RequestEditorFn) (*JobControlResponse, error)

	// JobInfo request
	JobInfoWithResponse(ctx context.Context, params *JobInfoParams, reqEditors ...RequestEditorFn) (*JobInfoResponse, error)

	// JobState request
	JobStateWithResponse(ctx context.Context, params *JobStateParams, reqEditors ...RequestEditorFn) (*JobStateResponse, error)

	// ListArrayJobs request
	ListArrayJobsWithResponse(ctx context.Context, params *ListArrayJobsParams, reqEditors ...RequestEditorFn) (*ListArrayJobsResponse, error)

	// ListJobCategories request
	ListJobCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobCategoriesResponse, error)

	// ListJobs request
	ListJobsWithResponse(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)
}

type AddArrayJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddArrayJobOutput
}

// Status returns HTTPResponse.Status
func (r AddArrayJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddArrayJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddJobOutput
}

// Status returns HTTPResponse.Status
func (r AddJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JobControlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Error
}

// Status returns HTTPResponse.Status
func (r JobControlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JobControlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JobInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobInfoOutput
}

// Status returns HTTPResponse.Status
func (r JobInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JobInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JobStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobStateOutput
}

// Status returns HTTPResponse.Status
func (r JobStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JobStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListArrayJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JobID
}

// Status returns HTTPResponse.Status
func (r ListArrayJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListArrayJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListJobCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JobID
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AddArrayJobWithBodyWithResponse request with arbitrary body returning *AddArrayJobResponse
func (c *ClientWithResponses) AddArrayJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddArrayJobResponse, error) {
	rsp, err := c.AddArrayJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddArrayJobResponse(rsp)
}

func (c *ClientWithResponses) AddArrayJobWithResponse(ctx context.Context, body AddArrayJobJSONRequestBody, reqEditors ...RequestEditorFn) (*AddArrayJobResponse, error) {
	rsp, err := c.AddArrayJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddArrayJobResponse(rsp)
}

// AddJobWithBodyWithResponse request with arbitrary body returning *AddJobResponse
func (c *ClientWithResponses) AddJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddJobResponse, error) {
	rsp, err := c.AddJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddJobResponse(rsp)
}

func (c *ClientWithResponses) AddJobWithResponse(ctx context.Context, body AddJobJSONRequestBody, reqEditors ...RequestEditorFn) (*AddJobResponse, error) {
	rsp, err := c.AddJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddJobResponse(rsp)
}

// DeleteJobWithResponse request returning *DeleteJobResponse
func (c *ClientWithResponses) DeleteJobWithResponse(ctx context.Context, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error) {
	rsp, err := c.DeleteJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobResponse(rsp)
}

// JobControlWithResponse request returning *JobControlResponse
func (c *ClientWithResponses) JobControlWithResponse(ctx context.Context, params *JobControlParams, reqEditors ...RequestEditorFn) (*JobControlResponse, error) {
	rsp, err := c.JobControl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJobControlResponse(rsp)
}

// JobInfoWithResponse request returning *JobInfoResponse
func (c *ClientWithResponses) JobInfoWithResponse(ctx context.Context, params *JobInfoParams, reqEditors ...RequestEditorFn) (*JobInfoResponse, error) {
	rsp, err := c.JobInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJobInfoResponse(rsp)
}

// JobStateWithResponse request returning *JobStateResponse
func (c *ClientWithResponses) JobStateWithResponse(ctx context.Context, params *JobStateParams, reqEditors ...RequestEditorFn) (*JobStateResponse, error) {
	rsp, err := c.JobState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJobStateResponse(rsp)
}

// ListArrayJobsWithResponse request returning *ListArrayJobsResponse
func (c *ClientWithResponses) ListArrayJobsWithResponse(ctx context.Context, params *ListArrayJobsParams, reqEditors ...RequestEditorFn) (*ListArrayJobsResponse, error) {
	rsp, err := c.ListArrayJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArrayJobsResponse(rsp)
}

// ListJobCategoriesWithResponse request returning *ListJobCategoriesResponse
func (c *ClientWithResponses) ListJobCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobCategoriesResponse, error) {
	rsp, err := c.ListJobCategories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobCategoriesResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// ParseAddArrayJobResponse parses an HTTP response from a AddArrayJobWithResponse call
func ParseAddArrayJobResponse(rsp *http.Response) (*AddArrayJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddArrayJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddArrayJobOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddJobResponse parses an HTTP response from a AddJobWithResponse call
func ParseAddJobResponse(rsp *http.Response) (*AddJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddJobOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobResponse parses an HTTP response from a DeleteJobWithResponse call
func ParseDeleteJobResponse(rsp *http.Response) (*DeleteJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJobControlResponse parses an HTTP response from a JobControlWithResponse call
func ParseJobControlResponse(rsp *http.Response) (*JobControlResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &JobControlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJobInfoResponse parses an HTTP response from a JobInfoWithResponse call
func ParseJobInfoResponse(rsp *http.Response) (*JobInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &JobInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobInfoOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJobStateResponse parses an HTTP response from a JobStateWithResponse call
func ParseJobStateResponse(rsp *http.Response) (*JobStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &JobStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobStateOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListArrayJobsResponse parses an HTTP response from a ListArrayJobsWithResponse call
func ParseListArrayJobsResponse(rsp *http.Response) (*ListArrayJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListArrayJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JobID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobCategoriesResponse parses an HTTP response from a ListJobCategoriesWithResponse call
func ParseListJobCategoriesResponse(rsp *http.Response) (*ListJobCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListJobCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JobID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"pS4AAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

