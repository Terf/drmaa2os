// Package genclient provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.8.1 DO NOT EDIT.
package genclient

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/pkg/errors"
)

// Defines values for JobState.
const (
	JobStateDone JobState = "done"

	JobStateFailed JobState = "failed"

	JobStateQueued JobState = "queued"

	JobStateQueuedHeld JobState = "queuedHeld"

	JobStateRequeued JobState = "requeued"

	JobStateRequeuedHeld JobState = "requeuedHeld"

	JobStateRunning JobState = "running"

	JobStateSuspended JobState = "suspended"

	JobStateUndetermined JobState = "undetermined"

	JobStateUnset JobState = "unset"
)

// AddArrayJobOutput defines model for AddArrayJobOutput.
type AddArrayJobOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobID)
	JobID `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// AddJobOutput defines model for AddJobOutput.
type AddJobOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobID)
	JobID `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// error string
type Error string

// JobID defines model for JobID.
type JobID string

// JobInfo defines model for JobInfo.
type JobInfo struct {
	AllocatedMachines []string  `json:"allocatedMachines"`
	Annotation        string    `json:"annotation"`
	CpuTime           int64     `json:"cpuTime"`
	DispatchTime      time.Time `json:"dispatchTime"`
	ExitStatus        int       `json:"exitStatus"`
	FinishTime        time.Time `json:"finishTime"`
	Id                string    `json:"id"`
	JobOwner          string    `json:"jobOwner"`
	QueueName         string    `json:"queueName"`
	Slots             int       `json:"slots"`
	State             string    `json:"state"`
	SubState          string    `json:"subState"`
	SubmissionMachine string    `json:"submissionMachine"`
	SubmissionTime    time.Time `json:"submissionTime"`
	TerminatingSignal string    `json:"terminatingSignal"`
	WallclockTime     int64     `json:"wallclockTime"`
}

// JobInfoOutput defines model for JobInfoOutput.
type JobInfoOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobInfo)
	JobInfo `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/Error)
	Error `yaml:",inline"`
}

// JobState defines model for JobState.
type JobState string

// JobStateOutput defines model for JobStateOutput.
type JobStateOutput struct {
	// Embedded struct due to allOf(#/components/schemas/JobState)
	JobState `yaml:",inline"`
	// Embedded struct due to allOf(#/components/schemas/JobSubState)
	JobSubState `yaml:",inline"`
}

// JobSubState defines model for JobSubState.
type JobSubState string

// DRMAA2 job template definition
type JobTemplate struct {
	AccountingID      string                     `json:"accountingID"`
	Args              []string                   `json:"args"`
	CandidateMachines []string                   `json:"candidateMachines"`
	DeadlineTime      time.Time                  `json:"deadlineTime"`
	Email             []string                   `json:"email"`
	EmailOnStarted    bool                       `json:"emailOnStarted"`
	EmailOnTerminated bool                       `json:"emailOnTerminated"`
	ErrorPath         string                     `json:"errorPath"`
	InputPath         string                     `json:"inputPath"`
	JobCategory       string                     `json:"jobCategory"`
	JobEnvironment    JobTemplate_JobEnvironment `json:"jobEnvironment"`
	JobName           string                     `json:"jobName"`
	JoinFiles         bool                       `json:"joinFiles"`
	MachineArch       string                     `json:"machineArch"`
	MachineOs         string                     `json:"machineOs"`
	MaxSlots          int64                      `json:"maxSlots"`
	MinPhysMemory     int64                      `json:"minPhysMemory"`
	MinSlots          int64                      `json:"minSlots"`
	OutputPath        string                     `json:"outputPath"`
	Priority          int64                      `json:"priority"`
	QueueName         string                     `json:"queueName"`
	ReRunnable        bool                       `json:"reRunnable"`
	RemoteCommand     string                     `json:"remoteCommand"`
	ReservationID     string                     `json:"reservationID"`
	ResourceLimits    JobTemplate_ResourceLimits `json:"resourceLimits"`
	StageInFiles      JobTemplate_StageInFiles   `json:"stageInFiles"`
	StageOutFiles     JobTemplate_StageOutFiles  `json:"stageOutFiles"`
	StartTime         time.Time                  `json:"startTime"`
	SubmitAsHold      bool                       `json:"submitAsHold"`
	WorkingDirectory  string                     `json:"workingDirectory"`
}

// JobTemplate_JobEnvironment defines model for JobTemplate.JobEnvironment.
type JobTemplate_JobEnvironment struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_ResourceLimits defines model for JobTemplate.ResourceLimits.
type JobTemplate_ResourceLimits struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_StageInFiles defines model for JobTemplate.StageInFiles.
type JobTemplate_StageInFiles struct {
	AdditionalProperties map[string]string `json:"-"`
}

// JobTemplate_StageOutFiles defines model for JobTemplate.StageOutFiles.
type JobTemplate_StageOutFiles struct {
	AdditionalProperties map[string]string `json:"-"`
}

// AddArrayJobJSONBody defines parameters for AddArrayJob.
type AddArrayJobJSONBody struct {
	// Embedded struct due to allOf(#/components/schemas/JobTemplate)
	JobTemplate `yaml:",inline"`
	// Embedded fields due to inline allOf schema
	Begin       int64  `json:"begin"`
	End         int64  `json:"end"`
	MaxParallel *int64 `json:"maxParallel,omitempty"`
	Step        *int64 `json:"step,omitempty"`
}

// AddJobJSONBody defines parameters for AddJob.
type AddJobJSONBody JobTemplate

// DeleteJobParams defines parameters for DeleteJob.
type DeleteJobParams struct {

	// ID of the job to manipulate
	JobID string `json:"jobID"`
}

// JobControlParams defines parameters for JobControl.
type JobControlParams struct {

	// ID of the job to manipulate
	JobID string `json:"jobID"`

	// action to perform (suspend, resume, hold, release, terminate)
	Action JobControlParamsAction `json:"action"`
}

// JobControlParamsAction defines parameters for JobControl.
type JobControlParamsAction string

// JobInfoParams defines parameters for JobInfo.
type JobInfoParams struct {

	// ID if the job for which the JobInfo should be returned
	JobID string `json:"jobID"`
}

// JobStateParams defines parameters for JobState.
type JobStateParams struct {

	// job ID the current job state should be queried for
	JobID string `json:"jobID"`
}

// ListArrayJobsParams defines parameters for ListArrayJobs.
type ListArrayJobsParams struct {

	// array job ID
	ArrayJobID string `json:"arrayJobID"`

	// number of records to skip for pagination
	Skip *int32 `json:"skip,omitempty"`

	// Maximum number of records to return. If not given the number of records are not limited.
	Limit *int32 `json:"limit,omitempty"`
}

// ListJobsParams defines parameters for ListJobs.
type ListJobsParams struct {

	// number of records to skip for pagination
	Skip *int32 `json:"skip,omitempty"`

	// maximum number of records to return
	Limit *int32 `json:"limit,omitempty"`
}

// AddArrayJobJSONRequestBody defines body for AddArrayJob for application/json ContentType.
type AddArrayJobJSONRequestBody AddArrayJobJSONBody

// AddJobJSONRequestBody defines body for AddJob for application/json ContentType.
type AddJobJSONRequestBody AddJobJSONBody

// Getter for additional properties for JobTemplate_JobEnvironment. Returns the specified
// element and whether it was found
func (a JobTemplate_JobEnvironment) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_JobEnvironment
func (a *JobTemplate_JobEnvironment) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_JobEnvironment to handle AdditionalProperties
func (a *JobTemplate_JobEnvironment) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_JobEnvironment to handle AdditionalProperties
func (a JobTemplate_JobEnvironment) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_ResourceLimits. Returns the specified
// element and whether it was found
func (a JobTemplate_ResourceLimits) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_ResourceLimits
func (a *JobTemplate_ResourceLimits) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_ResourceLimits to handle AdditionalProperties
func (a *JobTemplate_ResourceLimits) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_ResourceLimits to handle AdditionalProperties
func (a JobTemplate_ResourceLimits) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_StageInFiles. Returns the specified
// element and whether it was found
func (a JobTemplate_StageInFiles) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_StageInFiles
func (a *JobTemplate_StageInFiles) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_StageInFiles to handle AdditionalProperties
func (a *JobTemplate_StageInFiles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_StageInFiles to handle AdditionalProperties
func (a JobTemplate_StageInFiles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// Getter for additional properties for JobTemplate_StageOutFiles. Returns the specified
// element and whether it was found
func (a JobTemplate_StageOutFiles) Get(fieldName string) (value string, found bool) {
	if a.AdditionalProperties != nil {
		value, found = a.AdditionalProperties[fieldName]
	}
	return
}

// Setter for additional properties for JobTemplate_StageOutFiles
func (a *JobTemplate_StageOutFiles) Set(fieldName string, value string) {
	if a.AdditionalProperties == nil {
		a.AdditionalProperties = make(map[string]string)
	}
	a.AdditionalProperties[fieldName] = value
}

// Override default JSON handling for JobTemplate_StageOutFiles to handle AdditionalProperties
func (a *JobTemplate_StageOutFiles) UnmarshalJSON(b []byte) error {
	object := make(map[string]json.RawMessage)
	err := json.Unmarshal(b, &object)
	if err != nil {
		return err
	}

	if len(object) != 0 {
		a.AdditionalProperties = make(map[string]string)
		for fieldName, fieldBuf := range object {
			var fieldVal string
			err := json.Unmarshal(fieldBuf, &fieldVal)
			if err != nil {
				return errors.Wrap(err, fmt.Sprintf("error unmarshaling field %s", fieldName))
			}
			a.AdditionalProperties[fieldName] = fieldVal
		}
	}
	return nil
}

// Override default JSON handling for JobTemplate_StageOutFiles to handle AdditionalProperties
func (a JobTemplate_StageOutFiles) MarshalJSON() ([]byte, error) {
	var err error
	object := make(map[string]json.RawMessage)

	for fieldName, field := range a.AdditionalProperties {
		object[fieldName], err = json.Marshal(field)
		if err != nil {
			return nil, errors.Wrap(err, fmt.Sprintf("error marshaling '%s'", fieldName))
		}
	}
	return json.Marshal(object)
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// AddArrayJob request  with any body
	AddArrayJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddArrayJob(ctx context.Context, body AddArrayJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AddJob request  with any body
	AddJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	AddJob(ctx context.Context, body AddJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteJob request
	DeleteJob(ctx context.Context, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JobControl request
	JobControl(ctx context.Context, params *JobControlParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JobInfo request
	JobInfo(ctx context.Context, params *JobInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// JobState request
	JobState(ctx context.Context, params *JobStateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListArrayJobs request
	ListArrayJobs(ctx context.Context, params *ListArrayJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobCategories request
	ListJobCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ListJobs request
	ListJobs(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) AddArrayJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddArrayJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddArrayJob(ctx context.Context, body AddArrayJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddArrayJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddJobWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddJobRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AddJob(ctx context.Context, body AddJobJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAddJobRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteJob(ctx context.Context, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteJobRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JobControl(ctx context.Context, params *JobControlParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJobControlRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JobInfo(ctx context.Context, params *JobInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJobInfoRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) JobState(ctx context.Context, params *JobStateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewJobStateRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListArrayJobs(ctx context.Context, params *ListArrayJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListArrayJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobCategories(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobCategoriesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ListJobs(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewListJobsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewAddArrayJobRequest calls the generic AddArrayJob builder with application/json body
func NewAddArrayJobRequest(server string, body AddArrayJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddArrayJobRequestWithBody(server, "application/json", bodyReader)
}

// NewAddArrayJobRequestWithBody generates requests for AddArrayJob with any type of body
func NewAddArrayJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addarrayjob")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAddJobRequest calls the generic AddJob builder with application/json body
func NewAddJobRequest(server string, body AddJobJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewAddJobRequestWithBody(server, "application/json", bodyReader)
}

// NewAddJobRequestWithBody generates requests for AddJob with any type of body
func NewAddJobRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/addjob")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteJobRequest generates requests for DeleteJob
func NewDeleteJobRequest(server string, params *DeleteJobParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/deletejob")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobID", runtime.ParamLocationQuery, params.JobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJobControlRequest generates requests for JobControl
func NewJobControlRequest(server string, params *JobControlParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobcontrol")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobID", runtime.ParamLocationQuery, params.JobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJobInfoRequest generates requests for JobInfo
func NewJobInfoRequest(server string, params *JobInfoParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobinfo")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobID", runtime.ParamLocationQuery, params.JobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewJobStateRequest generates requests for JobState
func NewJobStateRequest(server string, params *JobStateParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/jobstate")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "jobID", runtime.ParamLocationQuery, params.JobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListArrayJobsRequest generates requests for ListArrayJobs
func NewListArrayJobsRequest(server string, params *ListArrayJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listarrayjobs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if queryFrag, err := runtime.StyleParamWithLocation("form", true, "arrayJobID", runtime.ParamLocationQuery, params.ArrayJobID); err != nil {
		return nil, err
	} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
		return nil, err
	} else {
		for k, v := range parsed {
			for _, v2 := range v {
				queryValues.Add(k, v2)
			}
		}
	}

	if params.Skip != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobCategoriesRequest generates requests for ListJobCategories
func NewListJobCategoriesRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listjobcategories")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewListJobsRequest generates requests for ListJobs
func NewListJobsRequest(server string, params *ListJobsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/listjobs")
	if operationPath[0] == '/' {
		operationPath = operationPath[1:]
	}
	operationURL := url.URL{
		Path: operationPath,
	}

	queryURL := serverURL.ResolveReference(&operationURL)

	queryValues := queryURL.Query()

	if params.Skip != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "skip", runtime.ParamLocationQuery, *params.Skip); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	if params.Limit != nil {

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

	}

	queryURL.RawQuery = queryValues.Encode()

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// AddArrayJob request  with any body
	AddArrayJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddArrayJobResponse, error)

	AddArrayJobWithResponse(ctx context.Context, body AddArrayJobJSONRequestBody, reqEditors ...RequestEditorFn) (*AddArrayJobResponse, error)

	// AddJob request  with any body
	AddJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddJobResponse, error)

	AddJobWithResponse(ctx context.Context, body AddJobJSONRequestBody, reqEditors ...RequestEditorFn) (*AddJobResponse, error)

	// DeleteJob request
	DeleteJobWithResponse(ctx context.Context, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error)

	// JobControl request
	JobControlWithResponse(ctx context.Context, params *JobControlParams, reqEditors ...RequestEditorFn) (*JobControlResponse, error)

	// JobInfo request
	JobInfoWithResponse(ctx context.Context, params *JobInfoParams, reqEditors ...RequestEditorFn) (*JobInfoResponse, error)

	// JobState request
	JobStateWithResponse(ctx context.Context, params *JobStateParams, reqEditors ...RequestEditorFn) (*JobStateResponse, error)

	// ListArrayJobs request
	ListArrayJobsWithResponse(ctx context.Context, params *ListArrayJobsParams, reqEditors ...RequestEditorFn) (*ListArrayJobsResponse, error)

	// ListJobCategories request
	ListJobCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobCategoriesResponse, error)

	// ListJobs request
	ListJobsWithResponse(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error)
}

type AddArrayJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddArrayJobOutput
}

// Status returns HTTPResponse.Status
func (r AddArrayJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddArrayJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AddJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AddJobOutput
}

// Status returns HTTPResponse.Status
func (r AddJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AddJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteJobResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Error
}

// Status returns HTTPResponse.Status
func (r DeleteJobResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteJobResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JobControlResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Error
}

// Status returns HTTPResponse.Status
func (r JobControlResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JobControlResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JobInfoResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobInfoOutput
}

// Status returns HTTPResponse.Status
func (r JobInfoResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JobInfoResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type JobStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *JobStateOutput
}

// Status returns HTTPResponse.Status
func (r JobStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r JobStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListArrayJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JobID
}

// Status returns HTTPResponse.Status
func (r ListArrayJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListArrayJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobCategoriesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]string
}

// Status returns HTTPResponse.Status
func (r ListJobCategoriesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobCategoriesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ListJobsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *[]JobID
}

// Status returns HTTPResponse.Status
func (r ListJobsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ListJobsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// AddArrayJobWithBodyWithResponse request with arbitrary body returning *AddArrayJobResponse
func (c *ClientWithResponses) AddArrayJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddArrayJobResponse, error) {
	rsp, err := c.AddArrayJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddArrayJobResponse(rsp)
}

func (c *ClientWithResponses) AddArrayJobWithResponse(ctx context.Context, body AddArrayJobJSONRequestBody, reqEditors ...RequestEditorFn) (*AddArrayJobResponse, error) {
	rsp, err := c.AddArrayJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddArrayJobResponse(rsp)
}

// AddJobWithBodyWithResponse request with arbitrary body returning *AddJobResponse
func (c *ClientWithResponses) AddJobWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*AddJobResponse, error) {
	rsp, err := c.AddJobWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddJobResponse(rsp)
}

func (c *ClientWithResponses) AddJobWithResponse(ctx context.Context, body AddJobJSONRequestBody, reqEditors ...RequestEditorFn) (*AddJobResponse, error) {
	rsp, err := c.AddJob(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAddJobResponse(rsp)
}

// DeleteJobWithResponse request returning *DeleteJobResponse
func (c *ClientWithResponses) DeleteJobWithResponse(ctx context.Context, params *DeleteJobParams, reqEditors ...RequestEditorFn) (*DeleteJobResponse, error) {
	rsp, err := c.DeleteJob(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteJobResponse(rsp)
}

// JobControlWithResponse request returning *JobControlResponse
func (c *ClientWithResponses) JobControlWithResponse(ctx context.Context, params *JobControlParams, reqEditors ...RequestEditorFn) (*JobControlResponse, error) {
	rsp, err := c.JobControl(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJobControlResponse(rsp)
}

// JobInfoWithResponse request returning *JobInfoResponse
func (c *ClientWithResponses) JobInfoWithResponse(ctx context.Context, params *JobInfoParams, reqEditors ...RequestEditorFn) (*JobInfoResponse, error) {
	rsp, err := c.JobInfo(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJobInfoResponse(rsp)
}

// JobStateWithResponse request returning *JobStateResponse
func (c *ClientWithResponses) JobStateWithResponse(ctx context.Context, params *JobStateParams, reqEditors ...RequestEditorFn) (*JobStateResponse, error) {
	rsp, err := c.JobState(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseJobStateResponse(rsp)
}

// ListArrayJobsWithResponse request returning *ListArrayJobsResponse
func (c *ClientWithResponses) ListArrayJobsWithResponse(ctx context.Context, params *ListArrayJobsParams, reqEditors ...RequestEditorFn) (*ListArrayJobsResponse, error) {
	rsp, err := c.ListArrayJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListArrayJobsResponse(rsp)
}

// ListJobCategoriesWithResponse request returning *ListJobCategoriesResponse
func (c *ClientWithResponses) ListJobCategoriesWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*ListJobCategoriesResponse, error) {
	rsp, err := c.ListJobCategories(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobCategoriesResponse(rsp)
}

// ListJobsWithResponse request returning *ListJobsResponse
func (c *ClientWithResponses) ListJobsWithResponse(ctx context.Context, params *ListJobsParams, reqEditors ...RequestEditorFn) (*ListJobsResponse, error) {
	rsp, err := c.ListJobs(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseListJobsResponse(rsp)
}

// ParseAddArrayJobResponse parses an HTTP response from a AddArrayJobWithResponse call
func ParseAddArrayJobResponse(rsp *http.Response) (*AddArrayJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddArrayJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddArrayJobOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseAddJobResponse parses an HTTP response from a AddJobWithResponse call
func ParseAddJobResponse(rsp *http.Response) (*AddJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &AddJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AddJobOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteJobResponse parses an HTTP response from a DeleteJobWithResponse call
func ParseDeleteJobResponse(rsp *http.Response) (*DeleteJobResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &DeleteJobResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJobControlResponse parses an HTTP response from a JobControlWithResponse call
func ParseJobControlResponse(rsp *http.Response) (*JobControlResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &JobControlResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Error
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJobInfoResponse parses an HTTP response from a JobInfoWithResponse call
func ParseJobInfoResponse(rsp *http.Response) (*JobInfoResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &JobInfoResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobInfoOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseJobStateResponse parses an HTTP response from a JobStateWithResponse call
func ParseJobStateResponse(rsp *http.Response) (*JobStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &JobStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest JobStateOutput
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListArrayJobsResponse parses an HTTP response from a ListArrayJobsWithResponse call
func ParseListArrayJobsResponse(rsp *http.Response) (*ListArrayJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListArrayJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JobID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobCategoriesResponse parses an HTTP response from a ListJobCategoriesWithResponse call
func ParseListJobCategoriesResponse(rsp *http.Response) (*ListJobCategoriesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListJobCategoriesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []string
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseListJobsResponse parses an HTTP response from a ListJobsWithResponse call
func ParseListJobsResponse(rsp *http.Response) (*ListJobsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &ListJobsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest []JobID
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}

